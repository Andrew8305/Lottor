# 基于可靠消息方案的分布式事务：Lottor使用

## 分布式事务
> 分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。

首先，解释下事务的概念：一组操作要么都完成之后提交，要么全部回滚。分布式事务特指在分布式环境下，一次事务设计多个服务进程，说白了就是跨进程的事务，这样就不能控制事务组的一致性。

分布式系统区别于传统的单体应用，单体应用的服务模块和数据都在一个服务中，使用Spring框架的事务管理器即可满足事务的属性。而分布式系统中，来自客户端的一次请求往往涉及多个服务，事务的一致性问题由此产生。

## 解决方案
### 强一致方案
X/Open 组织（即现在的 Open Group ）定义了分布式事务处理模型。 X/Open DTP 模型（ 1994 ）包括应用程序（ AP ）、事务管理器（ TM ）、资源管理器（ RM ）、通信资源管理器（ CRM ）四部分。

> XA 就是 X/Open DTP 定义的交易中间件与数据库之间的接口规范（即接口函数），交易中间件用它来通知数据库事务的开始、结束以及提交、回滚等。 XA 接口函数由数据库厂商提供。

#### 2PC
二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。第一阶段：准备阶段(投票阶段)和第二阶段：提交阶段（执行阶段）。

#### 3PC
三阶段提交（Three-phase commit），也叫三阶段提交协议（Three-phase commit protocol），是二阶段提交（2PC）的改进版本。

### 柔性事务
根据BASE理论，系统并不保证续进程或者线程的访问都会返回最新的更新过的值。系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后可以读到。

弱一致性的特定形式。系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。在没有故障发生的前提下，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。DNS 是一个典型的最终一致性系统。 在工程实践上，为了保障系统的可用性，互联网系统大多将强一致性需求转换成最终一致性的需求，并通过系统执行幂等性的保证，保证数据的最终一致性。但在电商等场景中，对于数据一致性的解决方法和常见的互联网系统（如 MySQL 主从同步）又有一定区别。
#### 补偿机制：TCC
TCC 其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：

- Try 阶段主要是对业务系统做检测及资源预留
- Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行Confirm阶段时，默认 Confirm阶段是不会出错的。
- Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。
#### 本地消息表
类似于可靠消息方案。
消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。

消息消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，那么就会重试执行。如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。

生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。如果有靠谱的自动对账补账逻辑，这种方案还是非常实用的。
#### 事务消息

RocketMQ第一阶段发送Prepared消息时，会拿到消息的地址，第二阶段执行本地事物，第三阶段通过第一阶段拿到的地址去访问消息，并修改消息的状态。
## Lottor介绍
Lottor用于解决微服务架构下分布式事务的问题，基于可靠性消息事务模型实现。

### Lottor的结构
Lottor由三部分组成：

- Lottor Server
- Lottor Client
- Lottor UI

Lottor服务器与客户端之间的通信使用的高性能通信框架：Netty。所有的客户端（生产端和消费端）都会与服务器保持长连接。Lottor UI用于展示系统中的事务组详细信息，包括预提交的事务组、消费失败的事务消息，并支持页面操作失败的消息（如补偿或重试）。

![Lottor的设计](http://ovcibtedi.bkt.clouddn.com/lottor-arche.jpg)

### 功能介绍

生产方分为三步：

- 预发送消息，首先会将消费方的事务组（一条或多条事务消息）组装好，并发送到Lottor Server，事务消息的状态为`预发送`。
- 执行本地事务：预发送之后，将会执行本地事务。
- 发送确认消息：根据本地事务的执行结果，异步发送确认消息。如果本地事务出现异常，回滚本地事务，并将异常信息捕捉一起发送到Lottor Server。本地也会持久化该状态（定期删除）。

Lottor Server：

- 接收预提交消息：收到预提交消息，将事务组中的事务消息分别保存，状态为`pre-commit`。
- 接收确认消息：状态为confirm，将更改相应的事务组状态，并将消息发送到对应的消费方（MQ异步实现），并标记事务消息的状态为`unconsumed`。否则，回滚状态只会修改事务组状态（定期删除）。
- 回查预发送消息的状态：状态为`pre-commit`的事务组消息，Lottor Server将会定期回查生产方。
- 回查事务消息的状态：状态为`unconsumed`（一般4h），Lottor Server将会定期回查消费方。

消费方：

- 接收事务消息：订阅相关的主题，消费完成之后，将会异步发送ACK给Lottor Server，消费失败会将异常返回给Lottor Server。本地也会持久化消费的状态（定期删除）。

Lottor 客户端的持久化，提供了SPI接口，可通过配置动态指定。目前支持：JDBC、Redis、MongoDB和文件系统。

### 告警和重试机制
这里所说的告警机制及消费补偿是针对消费端，可靠消息方案是保证了事务消息一定能够到达消费方，但是消费方可能因为某些原因而无法成功消费，有些消费异常是可以通过重试解决的，而有些异常是需要告警之后人工干预的。比如消费方暂时不可用，或者是多个消费方消费的顺序问题，可以通过定时的重试机制完成。而如果是由于生产方发送的事务消息出错（参数构造错误），此时消费方已经提交了本地事务组，所以是无法通过重试实现成功消费，导致需要告警，人为解决脏数据的问题。

### 适用场景
对于分布式系统的吞吐量有较高的要求，以及能够满足最终一致性的场景。如上面提到的告警机制及消费补偿，分布式事务是对微服务系统的完善，但是并不能完全保证一致性，可能需要通过告警等手段解决极端问题产生的不一致情况。

### 项目截图

![项目结构](http://ovcibtedi.bkt.clouddn.com/lottor-structure.jpg)

![UI界面](http://ovcibtedi.bkt.clouddn.com/lottor-ui.jpg)

![首页](http://ovcibtedi.bkt.clouddn.com/lottor-index.jpg)

![事务组信息](http://ovcibtedi.bkt.clouddn.com/lottor-group.jpg)

![事务组状态](http://ovcibtedi.bkt.clouddn.com/lottor-gropu-state.jpg)

#### 订阅最新文章，欢迎关注我的公众号

![微信公众号](http://ovci9bs39.bkt.clouddn.com/qrcode_for_gh_ca56415d4966_430.jpg)


